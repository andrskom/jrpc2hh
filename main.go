package main

import (
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"log"
	"math/rand"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"time"
)

type ServiceGenData struct {
	Package  string
	Service  string
	Methods  []string
	Packages map[string]*bool
}

type MethodGenData struct {
	Method      string
	ArgsBlock   string
	ResultBlock string
}

type ImportMap map[string]*string

func NewImportMap() *ImportMap {
	am := make(ImportMap)
	am["github.com/andrskom/jrpc2hh/models"] = "jModel"
	return &am
}

func (am *ImportMap) Register(i string) {
	if _, ok := am[i]; !ok {
		am[i] = nil
	}
}

func (am *ImportMap) GenerateAlias() {
	crossMap := make(map[string]*bool)
	for i, a := range am {
		var p string
		if strings.Contains(i, "/") {
			path := strings.Split(i, "/")
			p = paht[len(path)-1]
		} else {
			p = i
		}
		if _, ok := crossMap[p]; !ok {
			crossMap[p] = nil
		} else {
			am[i] = fmt.Sprintf("%s_%d", p, randomNumberGenerator().Int())
		}
	}
}

func randomNumberGenerator() *rand.Rand {
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	return r1
}

func main() {
	var hDir string
	flag.StringVar(&hDir, "s", "../../../service", "Service dir")
	flag.Parse()

	err := cleanAutoGeneratedFiles(hDir)
	logFatal("Error in autogenrated file deliting", err)

	fs := token.NewFileSet()
	packages, err := parser.ParseDir(fs, hDir, nil, parser.ParseComments)
	logFatal("Parsing dir error", err)

	regExpService, err := regexp.Compile("jrpc2hh:service\\n")
	logFatal("Compiling regexp for service error", err)

	regExpMethod, err := regexp.Compile("jrpc2hh:method\\n")
	logFatal("Compiling regep for method error", err)

	sTmpl, err := template.ParseFiles("./templates/service.tmpl")
	logFatal("Can't parse service template", err)

	mTmpl, err := template.ParseFiles("./templates/method.tmpl")
	logFatal("Can't parse method template", err)

	log.Print(regExpService, regExpMethod, sTmpl, mTmpl)

	if len(packages) != 1 {
		log.Fatal("Expected that only one package will be parse")
	}
	for name, p := range packages {
		log.Print(name, p)
	}
}

func logFatal(comment string, err error) {
	if err != nil {
		log.Fatal(fmt.Sprintf("%s: %s", comment, err.Error()))
	}
}

func cleanAutoGeneratedFiles(sDir string) error {
	regExpFile, err := regexp.Compile(`.*/jrpc2hh_.+\.go`)
	if err != nil {
		return err
	}
	dFun := func(path string, f os.FileInfo, err error) error {
		if regExpFile.Match([]byte(path)) {
			os.Remove(path)
		}
		return nil
	}
	return filepath.Walk(sDir, dFun)
}
