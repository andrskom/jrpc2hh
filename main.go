package main

import (
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"text/template"
	"github.com/andrskom/jrpc2hh/import"
	"strings"
	"reflect"
	"go/ast"
	"github.com/andrskom/jrpc2hh/service"
	"github.com/andrskom/jrpc2hh/method"
)

func main() {
	var hDir string
	flag.StringVar(&hDir, "s", "../../../service", "Service dir")
	flag.Parse()

	err := cleanAutoGeneratedFiles(hDir)
	logFatal("Error in autogenrated file deliting", err)

	fs := token.NewFileSet()
	packages, err := parser.ParseDir(fs, hDir, nil, parser.ParseComments)
	logFatal("Parsing dir error", err)

	regExpService, err := regexp.Compile("//[ ]*jrpc2hh:service")
	logFatal("Compiling regexp for service error", err)

	regExpMethod, err := regexp.Compile("//[ ]*jrpc2hh:method")
	logFatal("Compiling regep for method error", err)

	sTmpl, err := template.ParseFiles("./templates/service.tmpl")
	logFatal("Can't parse service template", err)

	mTmpl, err := template.ParseFiles("./templates/method.tmpl")
	logFatal("Can't parse method template", err)

	log.Print(sTmpl, mTmpl)

	if len(packages) != 1 {
		log.Fatal("Expected that only one package will be parse")
	}

	iMap := jrpc2hh.NewImportMap()
	sl := make(service.ServiceList)
	ml := make(method.MethodList)

	for _, p := range packages {
		for _, f := range p.Files {
			// collect imports
			localIMap := make(map[string]string)
			for _, im := range f.Imports {
				pV := strings.Trim(im.Path.Value, "\"")
				iMap.Register(pV)
				if im.Name != nil {
					localIMap[im.Name.String()] = pV
				} else {
					localIMap[pV] = pV
				}
			}

			// collect structs
			for _, d := range f.Decls {
				if reflect.TypeOf(d).Elem().Name() == "GenDecl" {
					gd, ok := (d).(*ast.GenDecl)
					if !ok {
						log.Fatal("Bad assertation type GenDecl")
					}
					if gd.Tok.String() == "type" && docHasMatch(regExpService, gd.Doc) {
						if len(gd.Specs) != 1 {
							log.Fatal("Bad Specs for type")
						}
						spec, ok := gd.Specs[0].(*ast.TypeSpec)
						if !ok {
							log.Fatal("Bad assertation TypeSpec")
						}
						if spec.Name == nil {
							log.Fatal("Bad Ident for types spec")
						}
						sl.Add(spec.Name.Name)
					}
				} else if reflect.TypeOf(d).Elem().Name() == "FuncDecl" {
					fd, ok := (d).(*ast.FuncDecl)
					if !ok {
						log.Fatal("Bad assertation func FunDecl")
					}
					if docHasMatch(regExpMethod, fd.Doc) {
						mN := fd.Name.String()
						if fd.Recv == nil {
							log.Fatal("Recv of service method can't be nil")
						}
						if len(fd.Recv.List) != 1 {
							log.Fatal("List of recv service method can't be nil")
						}
						mT, ok := (fd.Recv.List[0].Type).(*ast.StarExpr)
						if !ok {
							log.Fatal("Type associated with method must be pointer")
						}
						i, ok := (mT.X).(*ast.Ident)
						if !ok {
							log.Fatal("Bad Ident for method spec")
						}
						assType := i.Name

						if len(fd.Type.Params.List) != 2 {
							log.Fatal("Count of params must be equal 2")
						}
						argsAst := fd.Type.Params.List[0]
						resAst := fd.Type.Params.List[1]

						var args *method.Struct
						var res *method.Struct

						switch reflect.TypeOf(argsAst.Type).String() {
						case "*ast.SelectorExpr":
							t := (argsAst.Type).(*ast.SelectorExpr)
							x, ok := (t.X).(*ast.Ident)
							if !ok {
								log.Fatal("Bad assertation type")
							}
							if _, ok := localIMap[x.Name]; !ok {
								log.Fatal("Problem with inport and alias")
							}
							args = method.NewStruct(localIMap[x.Name], t.Sel.Name)
						case "*ast.Ident":
							t := (argsAst.Type).(*ast.Ident)
							args = method.NewStruct("", t.Name)
						default:
							log.Fatal("Unknown type of args")
						}

						if reflect.TypeOf(resAst.Type).String() != "*ast.StarExpr" {
							log.Fatal("Result must be pointer")
						}

						sE, _ := (resAst.Type).(*ast.StarExpr)

						switch reflect.TypeOf(sE.X).String() {
						case "*ast.StarExpr":
							t := (sE.X).(*ast.StarExpr)
							switch reflect.TypeOf(t.X).String() {
							case "*ast.Ident":
								t := (t.X).(*ast.Ident)
								res = method.NewStruct("", t.Name)
								res.SetPrefix("*")
							case "*ast.SelectorExpr":
								t := (t.X).(*ast.SelectorExpr)
								x, ok := (t.X).(*ast.Ident)
								if !ok {
									log.Fatal("Bad assertation type")
								}
								if _, ok := localIMap[x.Name]; !ok {
									log.Fatal("Problem with inport and alias")
								}
								res = method.NewStruct(localIMap[x.Name], t.Sel.Name)
								res.SetPrefix("*")
							default:
								log.Fatal("Unknown type of res")
							}
						case "*ast.SelectorExpr":
							t := (sE.X).(*ast.SelectorExpr)
							x, ok := (t.X).(*ast.Ident)
							if !ok {
								log.Fatal("Bad assertation type")
							}
							if _, ok := localIMap[x.Name]; !ok {
								log.Fatal("Problem with inport and alias")
							}
							res = method.NewStruct(localIMap[x.Name], t.Sel.Name)
						case "*ast.Ident":
							t := (sE.X).(*ast.Ident)
							res = method.NewStruct("", t.Name)
						default:
							log.Fatal("Unknown type of res")
						}
						ml.Add(assType, method.NewMethod(mN, args, res))
					}
				}
			}
		}
	}

	log.Print("---------------------------")
	iMap.GenerateAlias()
	log.Print(iMap)
	log.Print(sl)
	log.Print(ml)
}

func docHasMatch(regexp *regexp.Regexp, doc *ast.CommentGroup) bool {
	res := false
	if doc != nil {
		for _, cm := range doc.List {
			if regexp.Match([]byte(cm.Text)) {
				res = true
			}
		}
	}

	return res
}

func logFatal(comment string, err error) {
	if err != nil {
		log.Fatal(fmt.Sprintf("%s: %s", comment, err.Error()))
	}
}

func cleanAutoGeneratedFiles(sDir string) error {
	regExpFile, err := regexp.Compile(`.*/jrpc2hh_.+\.go`)
	if err != nil {
		return err
	}
	dFun := func(path string, f os.FileInfo, err error) error {
		if regExpFile.Match([]byte(path)) {
			os.Remove(path)
		}
		return nil
	}
	return filepath.Walk(sDir, dFun)
}
